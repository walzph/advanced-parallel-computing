#include <iostream>
#include <chrono>
//#define EIGEN_DONT_VECTORIZE
//#include <Eigen/Dense>
#include <ctime>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include "../inc/sparse_ops.h"
#include "../inc/dense_ops.h"

using namespace Eigen;

bool check_results( float* p1, float* p2, int m, int k ) {
	for( auto i=0; i < m; ++i  ) {
		for( auto j=0; j<k; ++j ) {
		float diff = p1[i*k+j] - p2[i*k+j];
		//std::cout << "Val is " << p2[i] << std::endl;
		if( fabs(diff) > 1e-6 ) {
			std::cout << "[ERROR] Diff = " << diff << " P1=" << p1[i*k+j] << " P2=" << p2[i*k+j] << " : " << i << "," <<j << std::endl;
			return false;
		}
		}
	}
	return true;
}

/*void randfloatVals(float *matrix, int rows, int cols) {
        srand ( time(NULL) );

	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	std::uniform_real_distribution<> dis(1, 2);
	for (int i = 0; i < rows*cols; ++i ) {
        	//Use dis to transform the random unsigned int generated by gen into a double in [1, 2)
        	matrix[i] = dis(gen);// << ' '; //Each call to dis(gen) generates a new random double
    	}
}*/

void randTernaryVals(float *matrix, int rows, int cols, int sparsity) {
	srand ( time(NULL) );

	for( int i = 0; i < rows * cols; i++ ) {
		auto x = rand() % 100;
    if( x<sparsity ) matrix[i] = 0;
    else if( x%2 ) matrix[i] = +1;
    else matrix[i] = -1;
	}
}

void randBinaryVals(float *matrix, int rows, int cols) {
	srand ( time(NULL) );

	for( int i = 0; i < rows * cols; i++ ) {
		auto x = rand() % 2;
		if( x==0 ) matrix[i] = +1;
		else if( x==1 ) matrix[i] = -1;
		else {
	    std::cout << "[ERROR] Random value out of range" << std::endl;
      exit(1);
		}
	}
}

void randBinaryValss8(int8_t *matrix, int rows, int cols) {
        srand ( time(NULL) );

        for( int i = 0; i < rows * cols; i++ ) {
                auto x = rand() % 2;
                if( x==0 ) matrix[i] = +1;
                else if( x==1 ) matrix[i] = -1;
                else {
            std::cout << "[ERROR] Random value out of range" << std::endl;
      exit(1);
                }
        }
}

int main( int argc, char* argv[] ) {
	std::chrono::time_point<std::chrono::system_clock> start, end;
	std::chrono::duration<double> elapsed_seconds_sparse_new, elapsed_seconds_eigen;

	int iterations, blk_size=0, m, n, k, sparsity;

	if( argc==6 ) {
		m=atoi(argv[1]);
		n=atoi(argv[2]);
		k=atoi(argv[3]);
		sparsity=atoi(argv[4]);
		blk_size=0;//atoi(argv[5]);
		iterations=atoi(argv[5]);
	} else {
		std::cout << "[ERROR] Usage: test_cpu_dot_ops <M> <N> <K> <SPARSITY> <ITERATIONS>" << std::endl;
		return 1;
	}

	float *A = (float*)malloc( m * n * sizeof(float) );
	float *B = (float*)malloc( n * k * sizeof(float) );
	float *C = (float*)malloc( m * k * sizeof(float) );
	float *Cs = (float*)malloc( m * k * sizeof(float) );

	randTernaryVals( B, n, k, sparsity );
	randBinaryVals( A, m, n );

	std::cout << "[INFO] Running Eigen Dense Matrix-Matrix Product (float32) ..." << std::endl;
  start = std::chrono::system_clock::now();
	for(int it=0; it<iterations; ++it) {
  	DenseDotProduct( A, B, C, m, n, k );
	}
	end = std::chrono::system_clock::now();
  elapsed_seconds_eigen = end-start;

	float *AT = (float*)malloc( n * m * sizeof(float) );
	float *BT = (float*)malloc( k * n * sizeof(float) );
	transposeMatrix( B, BT, n, k );
	transposeMatrix( A, AT, m, n );

  float *CT = (float*)malloc( m * k * sizeof(float));
	uint16_t** B_list=NULL;
  createSparseList( BT, B_list, +1, -1, n, k );

	std::cout << "[INFO] Running Sparse Matrix-Matrix Product ..." << std::endl;
  start = std::chrono::system_clock::now();
	for(int it=0; it<iterations; ++it) {
  	SparseDotProduct( AT, B_list, CT, +1, -1, m, n, k );
	}
  end = std::chrono::system_clock::now();
  elapsed_seconds_sparse_new = end-start;
  transposeMatrix( CT, Cs, k, m );

  if( check_results( C,  Cs, m, k ) ) std::cout << "[INFO] Sparse test ok" << std::endl;
  else std::cout << "[ERROR] Sparse test failed" << std::endl;

  std::cout << "[RESULT] Time Eigen (float32)   : " << (elapsed_seconds_eigen.count()/iterations) << "s" << std::endl;
	std::cout << "[RESULT] Time Sparse            : " << (elapsed_seconds_sparse_new.count()/iterations) << "s" << std::endl;

	free(A);
	free(B);
	free(BT);
	free(C);
	free(CT);
	free(Cs);

	return 0;
}
